React, Axios, Spring Boot, JPA, MySQL을 사용할 때 데이터가 흐르는 과정에서 **Front → Controller → Service → Repository → Entity → DB** 사이에서 이루어지는 **모든 매핑의 경우의 수**와, **각 매핑 시 변수명을 어떻게 해야 하는지**에 대한 정리.

---

# 📌 **데이터 흐름 및 매핑의 경우의 수**
## 1️⃣ **전체적인 데이터 흐름**
```
[React] → (Axios 요청)
    → [Controller] → (DTO 변환)
        → [Service] → (Entity 변환)
            → [Repository] → (DB 저장)
                → [DB]
                → (조회 후 Entity 반환)
            → [Service] → (Entity → DTO 변환)
        → [Controller] → (DTO → JSON 변환)
    → [React] (Axios 응답)
```
이제 이 흐름에 따라 **각 매핑의 경우의 수**를 설명하겠습니다.

---

# 🎯 **각 계층별 매핑 (이름 짓는 방식 포함)**

## 🔹 **1. Front(React) → Controller(Spring Boot)**
> **매핑 방식**: `JSON (프론트) → DTO (백엔드)`  
> **이름 예시**:
> - 프론트 JSON 필드명: `userName`, `userEmail`
> - DTO 필드명: `userName`, `userEmail`

📌 **예제 (React + Axios)**
```js
const requestBody = {
    userName: "John Doe",
    userEmail: "john@example.com"
};

axios.post("http://localhost:8080/api/users", requestBody)
    .then(response => console.log(response.data))
    .catch(error => console.error(error));
```

📌 **Controller에서 DTO 받기**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    @PostMapping
    public ResponseEntity<String> createUser(@RequestBody UserDTO userDTO) {
        return ResponseEntity.ok("User Created: " + userDTO.getUserName());
    }
}
```
💡 **이름 규칙**
- 프론트 JSON과 DTO의 필드명을 동일하게 맞추는 것이 좋습니다.
- 만약 다르다면 `@JsonProperty("json_key")`를 사용합니다.

---

## 🔹 **2. Controller → Service**
> **매핑 방식**: `DTO → Entity`  
> **이름 예시**:
> - DTO 필드명: `userName`, `userEmail`
> - Entity 필드명: `name`, `email`  
    > (DB 컬럼명이 `user_name`이라면, Entity 필드명을 `name`으로 변경 가능)

📌 **DTO → Entity 변환**
```java
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public User saveUser(UserDTO userDTO) {
        User user = new User();
        user.setName(userDTO.getUserName());
        user.setEmail(userDTO.getUserEmail());
        return userRepository.save(user);
    }
}
```
💡 **이름 규칙**
- DTO는 `userName`, `userEmail`처럼 프론트와 동일한 네이밍 유지
- Entity는 `name`, `email`처럼 DB 컬럼명을 반영하여 간결하게 변경 가능

---

## 🔹 **3. Service → Repository**
> **매핑 방식**: `Entity → DB` (JPA 자동 매핑)  
> **이름 예시**:
> - Entity 필드명: `name`, `email`
> - DB 컬럼명: `user_name`, `user_email`

📌 **Entity 설정**
```java
@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "user_name") // DB 컬럼명과 매핑
    private String name;

    @Column(name = "user_email")
    private String email;
}
```
📌 **Repository**
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
}
```
💡 **이름 규칙**
- Entity는 가독성을 위해 `name`, `email`처럼 짧게 유지
- `@Column(name = "user_name")`을 사용해 DB 컬럼과 매핑

---

## 🔹 **4. DB → Entity**
> **매핑 방식**: `DB → Entity` (JPA 자동 매핑)  
> **이름 예시**:
> - DB 컬럼명: `user_name`, `user_email`
> - Entity 필드명: `name`, `email`  
    > (JPA가 자동으로 매핑)

📌 **조회 예제**
```java
public User getUserById(Long id) {
    return userRepository.findById(id).orElseThrow();
}
```
💡 **이름 규칙**
- Entity 필드명을 간결하게 설정 (`name`, `email`)
- DB 컬럼명과 다르면 `@Column(name = "user_name")`을 사용

---

## 🔹 **5. Entity → DTO (Service에서 변환)**
> **매핑 방식**: `Entity → DTO`  
> **이름 예시**:
> - Entity 필드명: `name`, `email`
> - DTO 필드명: `userName`, `userEmail`

📌 **Entity → DTO 변환**
```java
public UserDTO convertToDTO(User user) {
    UserDTO userDTO = new UserDTO();
    userDTO.setUserName(user.getName());
    userDTO.setUserEmail(user.getEmail());
    return userDTO;
}
```
💡 **이름 규칙**
- DTO의 변수명은 프론트와 동일 (`userName`, `userEmail`)
- Entity는 DB 컬럼명을 반영 (`name`, `email`)

---

## 🔹 **6. DTO → JSON (Controller → Front)**
> **매핑 방식**: `DTO → JSON (ResponseBody)`  
> **이름 예시**:
> - DTO 필드명: `userName`, `userEmail`
> - JSON 필드명: `userName`, `userEmail`

📌 **Controller에서 DTO 반환**
```java
@GetMapping("/{id}")
public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
    User user = userService.getUserById(id);
    UserDTO userDTO = new UserDTO(user.getName(), user.getEmail());
    return ResponseEntity.ok(userDTO);
}
```
💡 **이름 규칙**
- DTO의 변수명과 JSON 키를 일치 (`userName`, `userEmail`)

---

# 🎯 **결론: 각 계층별 매핑 네이밍 정리**

React → Spring Boot → JPA → MySQL 간의 매핑 개념

| 계층 | 변수명 예시 | 매핑 방식 |
|------|-----------|-----------|
| **Front (JSON)** | `userName`, `userEmail` | JSON 요청 |
| **DTO** | `userName`, `userEmail` | DTO 변환 |
| **Entity** | `name`, `email` | DTO → Entity 변환 |
| **DB 컬럼명** | `user_name`, `user_email` | JPA ORM 매핑 |
| **Entity → DTO** | `name` → `userName`, `email` → `userEmail` | Entity → DTO 변환 |
| **DTO → JSON** | `userName`, `userEmail` | JSON 응답 |

✔ DTO 필드명은 프론트엔드의 JSON 키와 동일하게 작성하여 자동 매핑되도록 유지. 
✔ Entity 필드명은 가독성을 위해 간결하게 작성하고, DB 컬럼명과 다를 경우 @Column(name = "db_column")을 사용하여 매핑합니다.  
✔ JSON 필드명과 DTO 필드명이 다를 경우 `@JsonProperty("json_key")`를, DB 컬럼명과 Entity 필드명이 다를 경우 `@Column(name = "db_column")`을 사용하여 매핑./





---

---

### **🔹 계층별 이름 규칙 정리 (React, Spring Boot, JPA, MySQL 기준)**
React → Spring Boot → JPA → MySQL 간의 데이터 흐름에서 **각 계층별 변수명 규칙**을 정리했습니다.

---

## **1️⃣ 프론트엔드 (React, Axios)**
> 📌 **JSON 요청 및 응답 시 변수명 규칙**
- **카멜 케이스 (camelCase)** 사용 (`userName`, `userEmail`)
- API 요청 및 응답에서 **일관된 네이밍 유지**

✔ **예시 (React → 백엔드 요청)**
```js
const requestBody = {
    userName: "John Doe",
    userEmail: "john@example.com"
};

axios.post("http://localhost:8080/api/users", requestBody)
```

✔ **예시 (백엔드 → React 응답)**
```json
{
    "userName": "John Doe",
    "userEmail": "john@example.com"
}
```

---

## **2️⃣ DTO (Data Transfer Object)**
> 📌 **DTO 변수명 규칙**
- **프론트엔드의 JSON 키와 동일한 변수명 사용** (`userName`, `userEmail`)
- JSON과 자동 매핑되도록 `@JsonProperty` 필요 없음
- 단, JSON 키가 다를 경우 `@JsonProperty("json_key")` 사용

✔ **예시 (DTO 클래스)**
```java
public class UserDTO {
    private String userName;
    private String userEmail;

    // 기본 생성자
    public UserDTO() {}

    // Getter & Setter
    public String getUserName() { return userName; }
    public void setUserName(String userName) { this.userName = userName; }

    public String getUserEmail() { return userEmail; }
    public void setUserEmail(String userEmail) { this.userEmail = userEmail; }
}
```

✔ **만약 JSON 키가 다를 경우**
```java
import com.fasterxml.jackson.annotation.JsonProperty;

public class UserDTO {
    @JsonProperty("user_name")  // JSON의 "user_name"을 userName 필드에 매핑
    private String userName;

    @JsonProperty("user_email")
    private String userEmail;
}
```

---

## **3️⃣ Entity (JPA, Hibernate)**
> 📌 **Entity 변수명 규칙**
- **DB 컬럼명과 다를 경우 `@Column(name = "db_column")`으로 매핑**
- **가독성을 위해 필드명을 간결하게 작성** (`name`, `email`)
- `id`는 보통 `Long` 타입의 기본 키(`@Id` + `@GeneratedValue`)로 설정

✔ **예시 (Entity 클래스)**
```java
@Entity
@Table(name = "users") // DB 테이블명
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "user_name") // DB 컬럼명과 필드명이 다를 경우
    private String name;

    @Column(name = "user_email")
    private String email;

    // 기본 생성자
    public User() {}

    // Getter & Setter
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}
```

---

## **4️⃣ Repository (JPA)**
> 📌 **Repository 인터페이스 규칙**
- **클래스명은 `Entity명 + Repository` 형식으로 작성** (`UserRepository`)
- `JpaRepository<Entity, ID>` 를 상속받아 CRUD 지원

✔ **예시 (UserRepository)**
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
}
```

---

## **5️⃣ Service 계층**
> 📌 **Service 변수명 규칙**
- **DTO를 Entity로 변환할 때 DTO의 필드명을 Entity 필드에 맞게 매핑**
- Entity의 `name`, `email`을 DTO의 `userName`, `userEmail`로 변환

✔ **예시 (DTO → Entity 변환)**
```java
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public User saveUser(UserDTO userDTO) {
        User user = new User();
        user.setName(userDTO.getUserName());
        user.setEmail(userDTO.getUserEmail());
        return userRepository.save(user);
    }
}
```

✔ **예시 (Entity → DTO 변환)**
```java
public UserDTO convertToDTO(User user) {
    UserDTO userDTO = new UserDTO();
    userDTO.setUserName(user.getName());
    userDTO.setUserEmail(user.getEmail());
    return userDTO;
}
```

---

## **6️⃣ Controller 계층**
> 📌 **Controller 변수명 규칙**
- **API 엔드포인트는 RESTful 방식으로 작성** (`/api/users`)
- **DTO를 사용하여 JSON 데이터를 주고받음**
- `@RequestBody` 로 JSON을 DTO로 변환

✔ **예시 (POST 요청)**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    @PostMapping
    public ResponseEntity<String> createUser(@RequestBody UserDTO userDTO) {
        userService.saveUser(userDTO);
        return ResponseEntity.ok("User Created: " + userDTO.getUserName());
    }
}
```

✔ **예시 (GET 요청)**
```java
@GetMapping("/{id}")
public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
    User user = userService.getUserById(id);
    UserDTO userDTO = new UserDTO(user.getName(), user.getEmail());
    return ResponseEntity.ok(userDTO);
}
```

---

## **7️⃣ DB (MySQL)**
> 📌 **DB 컬럼명 규칙**
- **스네이크 케이스 (snake_case) 사용** (`user_name`, `user_email`)
- `id`는 기본 키 (`AUTO_INCREMENT` 설정)

✔ **예시 (users 테이블)**
```sql
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_name VARCHAR(255) NOT NULL,
    user_email VARCHAR(255) NOT NULL
);
```

---

# 🎯 **📌 최종 정리: 계층별 이름 규칙**

**React → Spring Boot → JPA → MySQL** 간의 데이터 흐름과 네이밍 규칙이었습니다.

| 계층 | 변수명 예시 | 네이밍 규칙 |
|------|-----------|-------------|
| **React (JSON)** | `userName`, `userEmail` | **카멜 케이스 (camelCase)** 사용 |
| **DTO** | `userName`, `userEmail` | **프론트 JSON과 동일한 변수명 유지** |
| **Entity** | `name`, `email` | **가독성을 위해 짧고 명확하게 작성** |
| **DB 컬럼명** | `user_name`, `user_email` | **스네이크 케이스 (snake_case) 사용** |
| **Repository** | `UserRepository` | **Entity명 + Repository** |
| **Service** | `saveUser()`, `getUserById()` | **기능 기반 네이밍 (동사+명사)** |
| **Controller** | `@RequestMapping("/api/users")` | **RESTful 방식의 URL 작성** |

